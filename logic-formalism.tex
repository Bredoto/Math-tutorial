\section{Формализм}

До сих пор все наши рассуждения были главным образом интуитивными, мы аппелировали к каким-то физическим образам и вводили нестрогие вспомогательные понятия вроде множеств (само понятие множества определяется в математике строго, но мы это сделаем лишь в следующей главе). Такой подход нельзя назвать безупречным с математической точки зрения, поэтому в этой главе мы формально введём уже рассматриваемые нами ранее понятия.  Вернее, не совсем формально, но я покажу, как это в целом делается. Этот параграф необязателен для дальнейшего понимания книги, но тем, кому важно доскональное понимание основ, он сможет немного помочь.

Состоять наше изложение логики будет из трёх частей: языка (то, как мы записываем предложения), синтаксиса (правила вывода одного предложения из другого) и семантики (наделение предложений предполагаемым смыслом). Главным образом причём мы будем говорить именно о языке, поскольку синтаксис и семантику мы в принципе уже рассмотрели и формальное изложение отличается не сильно.

Как мы уже отмечали, когда мы даём какое-то определение, мы всегда вынуждены пользоваться другими определениями. В конечном итоге мы обязаны ввести какое-то понятие, которое мы никак не определяем. Это называется <<принципом Мюнгхаузена>>: если бы мы не начинали построение математики от какого-то неопределяемого понятия, то получилось бы, что наши определения как-то зависимы друг от друга: условно говоря определение А базировалось бы на определении Б, а определение Б на определении А, и это в самом явном случае (зависимости могли бы быть самыми сложными теоретическими, но такие определения всегда были бы ошибочны). Хотя в определениях в общем-то допускаются перекрёстные ссылки друг на друга или даже самих на себя, где-то в любом случае любое определение должно ссылаться на понятие, которое мы ещё не определили.

В качестве понятия, которое мы никак не будем определять, у нас будет выступать \term{<<символ>>}. С точки зрения интуиции, символ~--- это некоторая закорючка на бумаге. С точки же зрения логики это понятие, которое мы принимаем без попыток понять что это.

\begin{definition}
\term{Алфавитом} назовём набор символов.
\end{definition}

\begin{example}
Примером алфавитов может служить русский или английский алфавит.
\end{example}

\begin{example}
Для нужд логики мы определим алфавит, состоящий из символов $\land$, $\lor$, $\to$, $\neg$, $\oplus$, $\leftrightarrow$, $\forall$, $\exists$, $=$, (, ) а так же всех символов английского языка, как строчных, так и заглавных. Сам этот алфавит будем обозначать как $\Sigma$.
\end{example}

Да, опять же нам надо как минимум определить что значит слово <<набор>>, используемое в определелнии алфавита. Это возможно сделать, но в такую степень формализма мы уже не будем углубляться, и если вы в дальнейшем найдёте где-то подобные дырки в определениях, отнеситесь к этому с пониманием. Мы могли бы привести все определения, но рассказ просто очень сильно тогда затянулся бы. Я же излагаю сейчас лишь то, что реально имеет какое-то отношение к практике и показываю как в целом фундамент логики строится.

\begin{definition}
\term{Строкой} (или так же \term{словом}) называется конечная упорядоченная последовательность сиволов (возможно, пустая) некоторого алвавита. Пустая строка для удобства обозначается как $\epsilon$.
\end{definition}

Строками алвавита $\Sigma$, определённого выше, являются например такие выражения как <<$\land\land P\oplus\leftrightarrow$>>. Строками русского алфавита будут такие последовательности как <<аплотфдц>>, а английского такие как <<shehs>>. Это совершенно бессмысленный набор символов, и отсюда ясно, что нам необходимо как-то из всех возможных строк выделить допустимые.

\begin{definition}
Набор слов (возможно, бесконечный) называется \term{языком}.
\end{definition}

Простейший, но одновременно с тем и почти бесполезный способ задания языка~--- это простое перечисление всех строк алфавита. В каких-то частных случаях это было бы возможно, но в целом это неинтересные либо непрактичные примеры. Очевидно, что перечислить все возможные предложения логики (или любого другого языка) без использования каких-то специальных механизмов явно невозможно.

\begin{definition}
\term{Грамматикой} называется некоторое формальное описание структуры допустимых слов языка.
\end{definition}

Это довольно нечёткое определение и как именно грамматику задавать может решать каждый сам для себя. Например, мы могли бы сконструировать язык, описывающий все возможные положения игры крестики-нолики. Для примера в качестве алфавита мы выберем набор $\{x, o, ?,1, 2\}$, а в качестве языка условимся называть все строки длины 10 этого алфавита, в которых первым символом идёт либо 1 либо 2 (что обозначает игрока, которому принадлежит ход), а оставшиеся символы будут обозначать подряд все клетки поля, где помимо крестиков и ноликов мы могли бы ставить символ $?$ для незанятых клеток. Примером такого слова может служить строка <<20?0?x???xx>>~--- она описывает ситуацию, изображенную в таблице~1.11.

\begin{table}[h]
\centering
\begin{tabular}{c | c | c}
o & & o\\
\hline
  & x & \\
\hline
 & x & x
\end{tabular}
\caption{Ход второго игрока}
\end{table}

Мы могли бы перечислить все слова языка крестиков-ноликов, но это было бы сложно, так как возможных слов, которые нам подходят, слишком много. Вместо этого мы явно указали, что вначале указывается чей ход, а затем позиция в девяти клетках. Такое описание можно считать грамматикой языка крестиков-ноликов.

В общем случае для задания грамматик и работы с ними существует целый ряд стандартных механизмов, которыми занимается раздел математики под названием <<Теория формальных языков>> и этими механизмами удобно пользоваться.

Самый простой способ задания грамматики языка~--- это разбить предложения языка на составные единицы и указать правила, по которым они составляются. Такие грамматики называются \term{контекстно-свободными}. Тут можно вспомнить уроки русского языка в школах: все изучали, что предложение состоит из составных частей вроде подлежащего, сказуемого, дополнения, вводного предложения, деепричастного оборота. Определения частей языка могут быть и рекурсивными, то есть ссылающимися на самих себя. Так, предложением является так же и набор из нескольких предложений, соединённых союзами. Эти элементы языка так же описываются с помощью других языковых элементов: подлежащее может быть представлено местоимением, существительным, числительным и т.п.

Таким же путём мы сейчас опишем грамматику предложений логики. Для удобства мы будем записывать правила в форме, подобной следующей:
$$a \to bad | ef | g$$
Здесь $a$~--- это объект языка, вертикальными чертами разделены различные варианты чем $a$ может являться, а между вертикальных черт записывается конкретная форма. Запись может разбиваться на несколько строк.

\begin{example}
Правило, приведённое выше говорит, что, например, запись  $bbefdd$ является элементом $a$. Действительно, $ef$ является элементом $a$. То есть мы можем сказать, что $bbefdd = bbadd$. Теперь, $bad$ в середине строки так же является элементом $a$: $bbadd = bad$. Собственно мы получили, что изначальная строка является элементом $a$.
\end{example}

Я не буду выписывать грамматику целиком, определив лишь базовые конструкиции для понятия \term{формулы}:\\
\\
Формула $\to$ атом | $\neg$ формула\\
\hspace*{2cm}| формула $\land$ формула | формула $\lor$ формула\\
\hspace*{2cm}| формула $\to$ формула | формула $\leftrightarrow$ формула\\
\hspace*{2cm}| $\forall$ \term{переменная} формула | $\exists$ \term{переменная} формула\\
Атом $\to$ терм = терм | \term{предикат} (списоктермов)\\
Терм $\to$ \term{константа} | \term{операция} (списоктермов)\\
Списоктермов $\to$ терм списоктермов | $\epsilon$\\
\\
Слова, которые я выделил курсивом (предикат, переменная, операция, константа)~--- это некоторые символы, которые мы каким-то произвольным образом разбили в группы. В каждой конкретной ситуации вы разбиваем эти символы по-разному. Например, так:\\
\\
Предикат $\to$ P | Q | R| $\ldots$\\
Переменная $\to$ x | y | z| $\ldots$\\
Операция $\to$ f | g | h | $\ldots$\\
Константа $\to$ a | b | c | $\ldots$\\
\\
Это уже целиком зависит от того, как мы собираемся использовать эти символы.

\begin{example}
Давайте разберём формулу $\forall x P(x) \to Q(f(y))$. Эта формула явно имеет вид <<$\forall$ переменная формула>>, в роли переменной выступает $x$, а в роли формулы $P(x) \to Q(f(y))$. Последняя так же состоит из двух формул $P(x)$ и $Q(f(y))$, соединённых символом $\to$. Обе эти формулы являются атомами вида <<предикат (списоктермов)>>. В случае $P(x)$ список термов состоит из единственного терма $x$ (более точно~--- из терма $x$ и спискатермов $\epsilon$), а в случае $Q(f(y))$ из единсвтенного терма $f(y)$. $x$ является переменной, а терм $f(y)$ имеет вид <<операция список термов>>. В качестве операции тут выступает $f$, а в качестве терма $y$, который является переменной.
\end{example}

Как видно, простая на вид запись на самом деле, если определять её формально, имеет довольно сложную структуру. Тем не менее для математической строгости мы обязаны это всё определять именно таким образом.

Сама по себе формула не обязательно является допустимым предложением языка логики. По крайней мере формула, приведённая в примере, не является корректным предложением логики, поскольку в ней переменная $y$ не понятно чем вообще является. Для полноценного определения языка логики нам потребуется еще два определения.

\begin{definition}
Переменная $v$ в составе формулы называется \term{свободной}, если перед этой формулой не написано $\exists v$ или $\forall v$.
\end{definition}

\begin{definition}
\term{Предложением} логики называется формула без свободных переменных.
\end{definition}

Вот теперь мы определили язык логики, которую мы рассматривали, целиком. Здесь требуется сделать однако несколько дополнительных ремарок уже по самому смыслу того, что мы определили.

Во-первых, читателя могло смутить, что мы никак не обмолвились о множествах и пишем теперь не $\forall x\in A$, а просто $\forall x$. Это связано с тем, что теория множеств сама по себе требует определения в терминах логики и мы введём её формально лишь в следующей главе. Теория множеств хороша для интуитивного понимания предикатов, но если строить фундамент математики последовательно, то мы вначале должны определить полноценную логику, а уже только потом на языке логики можно вводить множества.

Во-вторых, вас могла смутить запись $P(f(x))$ и термин <<операция>>. Формально это просто правило для записи предложений, интуитивно об этом можно думать как о некотором правиле, которое некоторым термам ставит в соответствие другой терм. Например, опять же воспользовавшись нестрогой интуицией, мы могли бы рассмотреть операцию $f$ как функцию, которая человеку сообщает его достаток. Если предикат $P$ означает достаток свыше миллиона, а $x$~--- это некоторый человек, то формула, выражающая высокий доход человека $x$ будет записываться как $P(f(x))$. Такие конструкции входят традиционно в язык логики, но с точки зрения интуиции и практики о них гораздо лучше рассуждать опираясь на теорию множеств, и поэтому я это оставил для следующей главы.

Ну и в заключение заметим, что введённый нами язык допускает запись $\forall x\ P(x)$, но не допускает записи $\forall P\ P(x)$. Это не просто так, посольку если бы мы допустили выражения в духе <<для любого предиката>>, то наша логика оказалась бы несколько сложнее. Такая логика используется, но для наших нужд она не пригодится. Для общей информации я лишь замечу, что логика, рассмотренная нами называется \term{логикой первого порядка}, если добавить к ней выражения <<для любого предиката>>, то это будет \term{логика второго порядка}, а если же, наоборот, кванторы убрать вовсе, то получится \term{логика высказываний}, так же называемая \term{логикой нулевого порядка}. Это всё нам не понадобится в дальнейшем, но упомянуть на всякий случай будет не лишним.

Язык логики определён, перейдём к синтаксису. Читатель теперь может понять формальное значение правил вроде
$$\alpha, \alpha\to\beta \vdash \beta$$
Здесь в качестве греческих букв может выступать любое предложение, а каждая из записей в левой части определяет структуру предложения, которая соответствует нашей контекстно-свободной грамматике. Символ $\vdash$ означает <<выводимость>>. Обычно правила вывода означают используя какую-то другую нотацию, чтобы не путать правило вывода и выводимость предложения в теории, но мы не будем различать эти понятия специально, поскольку у нас нет задачи глубоко изучать логику, мы лишь знакомимся с самыми основами.

Как мы уже упоминали, мы начинаем с некоторого набора аксиом, которые являются набором предложений языка логики. Применяя правила вывода, мы получаем из них теоремы. Набор всех выводимых теорем называется теорией. Символом $\Gamma$ мы будем обозначать некоторый произвольный набор предложений (для интуитции это удобно рассматривать как некоторый ограниченный набор теорем, выводимых из наших аксиом). В таблице~1.10 мы привели основные правила вывода, не касающиеся предикатов (правила вывода логики высказываний), теперь мы готовы сформулировать правила вывода и для кванторов.

\term{Unversal generalization}: Если $\Gamma \vdash P(c)$, то $\Gamma\vdash \forall x\ P(x)$.

Здесь $c$~--- это константа, $P$~--- формула со свободной переменной. Правило работает только в том случае, если $\Gamma$ не содержит ни одного предложения, содержащего $c$ и P не содержит переменных с именем $x$.

Интуитивно это можно интерпретировать так: если нам удалось вывести предложение $P(c)$, где $c$~--- произвольная константа, то мы точно так же могли бы вывести это предложение для любого элемента той теории, которую мы рассматриваем. Это интуиция конечно, с формальной же точки зрения это лишь правила, по которому одно предложение преобразовывается в другое.

\term{Universal instantiation}: Если $\Gamma \vdash \forall x\ P(x)$, то $\Gamma \vdash P(c)$.

Правило работает всегда. Интуитивно это правило очень простое: если мы доказали, что что-то выполняется для любого элемента, то для конкретного $c$ оно так же будет выполняться.

\term{Existential generalization}: Если $\Gamma \vdash P(c)$, то $\Gamma\vdash \exists x P(x)$.

Опять же правило работает всегда. Если мы вывели предложение $P$ для какого-то конкретного $c$, то среди всех возможных элементов найдётся такой, для которого $P$ истинно.

\term{Existential instantiation}: Если $\Gamma \vdash \exists x\ P(x)$, то $\Gamma \vdash P(c)$.

Это правило работает в том случае, если $c$ не используется ни в каком из предложений $\Gamma$ и не встречается в $P(x)$. Интуиция здесь так же простая: если мы доказали существование некоторого элемента, для которого выполняется $P$, то мы можем ввести для этого элемента обозначение $c$, при условии, что мы уже не используем это обозначение для чего-то другого.

На этом правила вывода заканчиваются.

\begin{example}
Давайте докажем импликацию $(\forall x\ A(x)) \to (\exists x\ A(x))$. Для этого первоначальный набор аксиом $\Gamma$ будем содержать лишь одно предложение $\forall x\ A(x)$.
\begin{enumerate}
\item $\Gamma\vdash \forall x\ A(x)$~--- дано;
\item $\Gamma \vdash A(c)$~--- universal instantiation;
\item $\Gamma, A(c) \vdash \exists A(x)$~--- existential generalization.
\end{enumerate}
\end{example}

В приведённом примере важно